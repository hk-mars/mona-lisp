
## Good Cleanness
So experience suggests we should embrace dirtiness. 
Or at least some forms of it; in other ways, the best quick-and-dirty programs are usually quite clean. 
Which kind of dirtiness is bad and which is good? The best kind of quick and dirty programs seem to be ones 
that are mathematically elegant, but missing features-- and particularly features that are inessential 
but deemed necessary for propriety. Good cleanness is a response to constraints imposed by the problem. 
Bad cleanness is a response to constraints imposed from outside-- by regulations, or the expectations of 
powerful organizations.

I think these two types of cleanness are not merely separate, but in opposition to one another. 
"The rules," whatever they are, are usually determined by politics; 
you can only obey them at the expense of mathematical elegance. And vice versa. -- Paul Graham

## Brevity 
what you like about abstraction.
By brevity I don't mean that programs should require fewer characters. 
That counts for something, but it is more important to require fewer tokens. -- Paul Graham

Mathematical expression(elegance form) is always a good way of abstraction for design brevity, but be remember that it is NOT the goal.

Strategical rules(defined constraints or format, but can be changed) is a needed way for design brevity, but this SHOULD only be used for the limitedness points of system.

Forced rules MUST never be used, it makes the design less brevity and broken.

## Clearly Understood Foundations
In Arc we hope to make programs as short or shorter, but at the same time to build the language up in a transparent way from clearly understood foundations. We're not doing this (just) out of fastidiousness. You have to build the language up transparently if you want users to be able to customize it. The chaotic semantics of Perl would make it very hard to add macros.  -- Paul Graham


